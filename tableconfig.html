<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Configure Mechamarkers Table</title>
    <style>
      * {
        margin: 0;
        padding: 0;
      }

      body {
          font-family: sans-serif;
          font-size: 12px;
          line-height: 1.5;
      }

      #imageVis {
          position: absolute;
          top: 0;
          right: 0;
          width: 80vw;
          height: 100vh;
          box-sizing: border-box;
          overflow: scroll;
          user-select: none;
      }

      #imageGrid {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
      }

      #pointGrid {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
      }

      #sidebar {
          position: absolute;
          top: 0;
          left: 0;
          width: 20vw;
          height: 100vh;
          min-width: 250px;
          overflow-x: visible;
          overflow-y: scroll;
          border-right: 1px solid #666;
      }

      #warning {
          min-height: 4em;
          color: blue;
      }

      #warning b {
          min-height: 4em;
          color: red;
      }

      .line {
          position: relative;
          float: left;
          width: 100%;
          padding: 0.6em 1em;
          box-sizing: border-box;
      }

      ul, ol {
          padding-left: 1.5em;
      }

      .line.full input {
          width: 100%;
      }

      .rightAlign {
          text-align: right;
      }

      input[type="button"] {
          min-width: 8em;
          min-height: 2em;
      }

      input[type="number"] {
          width: 4em;
      }

      .point {
          position: absolute;
          top: 0;
          left: 0;
          cursor: pointer;
      }

      .point span {
          position: absolute;
          top: -13px;
          left: 0;
          color: red;
      }

      .topleft {
          position: absolute;
          top: 0;
          left: 0;
          border-right: 1px solid red;
          border-bottom: 1px solid red;
      }

      .bottomright {
          position: absolute;
          bottom: 0;
          right: 0;
          border-top: 1px solid red;
          border-left: 1px solid red;
      }

      .point:hover span, .point:hover .topleft, .point:hover .bottomright {
          border-color: rgba(50, 200, 0, 1.0);
          color: rgba(50, 200, 0, 1.0);
      }

      .point.active span, .point.active .topleft, .point.active .bottomright {
          border-color: rgba(0, 200, 200, 1.0);
          color: rgba(0, 200, 200, 1.0);
      }

    </style>
  </head>

  <body>


    <div id="imageVis">
        <img id="imageGrid" src="">
        <div id="pointGrid"></div>
    </div>

    <div id="sidebar">

        <div class="line" id="warning"></div>

        <div class="line">
            <input type="button" value="zoom in" id="buttonZoomIn"/>
            <input type="button" value="zoom out" id="buttonZoomOut"/>
        </div>

        <div class="line rightAlign">
            X number of cells: <input id="xCount" type="number" value="12" min="1" step="1"/>
        </div>

        <div class="line rightAlign">
            Y number of cells: <input id="yCount" type="number" value="6" min="1" step="1"/>
        </div>

        <div class="line rightAlign">
            <b>Real world measurements</b>
        </div>

        <div class="line rightAlign">
            X cell width (mm): <input id="xWidth" type="number" value="90" min="0" step="0.1"/>
        </div>

        <div class="line rightAlign">
            Y cell height (mm): <input id="yHeight" type="number" value="110" min="0" step="0.1"/>
        </div>

        <div class="line rightAlign">
            left edge to left-most cell edge (mm): <input id="xOffset" type="number" value="12" min="0" step="0.1"/>
        </div>

        <div class="line rightAlign">
            top edge to top-most cell edge (mm): <input id="yOffset" type="number" value="12" min="0" step="0.1"/>
        </div>

        <div class="line rightAlign">
            camera X inverted: <input id="xInvert" type="checkbox" onchange="xInvert(this)" />
        </div>

        <div class="line rightAlign">
            camera Y inverted: <input id="xInvert" type="checkbox" onchange="yInvert(this)" />
        </div>

        <div class="line">
            <b>Calibration image: </b><input type="file" id="loadImage"/>
        </div>

        <div class="line full">
            <input type="button" value="Generate Calibration File" id="generateCalibration"/>
        </div>

        <div class="line">
            <br><br><br>
        </div>

        <div class="line full">
            Paste existing QUADS_CALIBRATED here:<br>
            <input type="text" value="" id="existingQuad"/>
        </div>

        <div class="line full">
            <input type="button" value="Apply Existing Quad Calibration" id="applyCalibration"/>
        </div>

        <div class="line">
            <br><br><br>
            <p><i>Instructions</i></p>
            <ol>
                <li>Set grid and camera parameters</li>
                <li>Load calibration image</li>
                <li>Click to select point to move
                    <ul>
                        <li>Click to move point to new position</li>
                        <li>Use arrow keys for fine adjustment</li>
                        <li>Esc deselects point</li>
                    </ul>
                </li>
                <li>Move all points to match grid intersections</li>
                <li>Generate calibration file
                    <ul>
                        <li>Paste quads text into QUADS_CALIBRATION variable in config.js</li>
                        <li>Paste cells text into CELLS_CALIBRATION variable in config.js</li>
                    </ul>
                </li>
                <li>You can also apply an existing QUADS_CALIBRATION to the points.</li>
            </ol>
        </div>

    </div>


    <script>

        var zoomLevel = 1.0;
        var zoomFactor = 1.2;
        var imgLoaded = false;
        var imgW = 0;
        var imgH = 0;
        var gridX = 0;
        var gridY = 0;
        var points = [];
        var pointSize = 31;
        var pointSelected = {x:-1, y:-1};
        var xInverted = false;
        var yInverted = false;

        class Point {
            constructor(x, y, ox, oy, w, h) {
                this.x = x;
                this.y = y;
                this.pos = {x: ox+x*w, y: oy+y*h};
            }

            init(div) {
                var pointElement = document.createElement('div');
                pointElement.setAttribute('id', 'point_'+this.x+'-'+this.y);
                pointElement.setAttribute('class', 'point');
                pointElement.setAttribute('onclick', 'pointClicked(this.id)');
                var html = '<span>' + this.x + ',' + this.y + '</span>';
                html = html + '<div class="topleft"></div><div class="bottomright"><div>';
                pointElement.innerHTML = html;
                document.getElementById(div).append(pointElement);
                var createdElement = document.getElementById('point_'+this.x+'-'+this.y);
                createdElement.style.left = (this.pos.x*imgW)-pointSize/2 + 'px';
                createdElement.style.top = (this.pos.y*imgH)-pointSize/2 + 'px';
                createdElement.style.width = pointSize + 'px';
                createdElement.style.height = pointSize + 'px';
                createdElement.querySelector('.topleft').style.width = Math.floor(pointSize/2) + 'px';
                createdElement.querySelector('.topleft').style.height = Math.floor(pointSize/2) + 'px';
                createdElement.querySelector('.bottomright').style.width = Math.floor(pointSize/2) + 'px';
                createdElement.querySelector('.bottomright').style.height = Math.floor(pointSize/2) + 'px';
            }

            resize() {
                var createdElement = document.getElementById('point_'+this.x+'-'+this.y);
                createdElement.style.left = (this.pos.x*imgW)-pointSize/2 + 'px';
                createdElement.style.top = (this.pos.y*imgH)-pointSize/2 + 'px';
                createdElement.style.width = pointSize + 'px';
                createdElement.style.height = pointSize + 'px';
                createdElement.querySelector('.topleft').style.width = Math.floor(pointSize/2) + 'px';
                createdElement.querySelector('.topleft').style.height = Math.floor(pointSize/2) + 'px';
                createdElement.querySelector('.bottomright').style.width = Math.floor(pointSize/2) + 'px';
                createdElement.querySelector('.bottomright').style.height = Math.floor(pointSize/2) + 'px';
            }

            update(x, y) {
                this.pos.x = x;
                this.pos.y = y;
                var createdElement = document.getElementById('point_'+this.x+'-'+this.y);
                createdElement.style.left = (this.pos.x*imgW)-pointSize/2 + 'px';
                createdElement.style.top = (this.pos.y*imgH)-pointSize/2 + 'px';
            }

            updatePos(mx, my) {
                this.pos.x = mx/imgW;
                this.pos.y = my/imgH;
                var createdElement = document.getElementById('point_'+this.x+'-'+this.y);
                createdElement.style.left = (this.pos.x*imgW)-pointSize/2 + 'px';
                createdElement.style.top = (this.pos.y*imgH)-pointSize/2 + 'px';
            }

            movePos(mx, my) {
                this.pos.x = (this.pos.x*imgW + mx)/imgW;
                this.pos.y = (this.pos.y*imgH + my)/imgH;
                this.pos.x = this.pos.x > 1 ? 1 : this.pos.x < 0 ? 0 : this.pos.x;
                this.pos.y = this.pos.y > 1 ? 1 : this.pos.y < 0 ? 0 : this.pos.y;
                var createdElement = document.getElementById('point_'+this.x+'-'+this.y);
                createdElement.style.left = (this.pos.x*imgW)-pointSize/2 + 'px';
                createdElement.style.top = (this.pos.y*imgH)-pointSize/2 + 'px';
            }
        }

        function resizePointGridDiv() {
            var pg = document.getElementById('pointGrid');
            pg.style.width = imgW + 'px';
            pg.style.height = imgH + 'px';
        }

        function pointClicked(id) {
            var idString = id.split('_')[1];
            var idArr = idString.split('-');
            pointSelected.x = Math.floor(idArr[0]);
            pointSelected.y = Math.floor(idArr[1]);
            var activeElements = document.getElementsByClassName('active');
            for (var i=0; i<activeElements.length; i++) {
                activeElements[i].classList.remove('active');
            }
            var selectedElement = document.getElementById(id);
            selectedElement.classList.add('active');
            updateWarning('Point '+idArr+' selected', false);
        }

        function windowClicked(mx, my) {
            if (pointSelected.x !== -1 && pointSelected.y !== -1) {
                var index = pointSelected.x*(gridY+1) + pointSelected.y;
                points[index].updatePos(mx, my);
            }
        }

        function arrowPressed(mx, my) {
            if (pointSelected.x !== -1 && pointSelected.y !== -1) {
                var index = pointSelected.x*(gridY+1) + pointSelected.y;
                points[index].movePos(mx, my);
            }
        }

        function handleFiles(e) {
            var fileExtArr = e.target.files[0].name.split('.');
            var fileExt = fileExtArr[fileExtArr.length-1];
            var image = document.getElementById('imageGrid');
            if (fileExt === 'jpg' || fileExt === 'png' || fileExt === 'JPG' || fileExt === 'PNG') {
                var url = URL.createObjectURL(e.target.files[0]);
                image.src = url;
                setTimeout(function() {
                    imgW = document.getElementById('imageGrid').width;
                    imgH = document.getElementById('imageGrid').height;
                    resizePointGridDiv();
                    generateNewPoints();
                    imgLoaded = true;
                    updateWarning('Image loaded', false);
                }, 1000);
            } else {
                imgLoaded = false;
                image.src = '';
                updateWarning('Please upload png or jpg files', true);
            }
        }

        function generateNewPoints() {
            document.getElementById('pointGrid').innerHTML = '';
            points = [];
            gridX = Math.round(document.getElementById('xCount').value);
            gridY = Math.round(document.getElementById('yCount').value);
            var offsetX = 0.05;
            var offsetY = 0.05;
            for (var i=0; i<=gridX; i++) {
                for (var j=0; j<=gridY; j++) {
                    points.push(new Point(i, j, offsetX, offsetY, (1-2*offsetX)/gridX, (1-2*offsetY)/gridY));
                }
            }

            points.forEach(p => p.init('pointGrid'));
        }

        function zoomIn() {
            zoomLevel = zoomLevel * zoomFactor;
            pointSize = pointSize * zoomFactor;
            document.getElementById('imageGrid').style.width = (zoomLevel*100) + '%';
            resizeGrid();
        }

        function zoomOut() {
            zoomLevel = zoomLevel / zoomFactor;
            pointSize = pointSize / zoomFactor;
            document.getElementById('imageGrid').style.width = (zoomLevel*100) + '%';
            resizeGrid();
        }

        function xInvert(checkEle) {
            xInverted = checkEle.checked ? true : false;
        }

        function yInvert(checkEle) {
            yInverted = checkEle.checked ? true : false;
        }

        function resizeGrid() {
            imgW = document.getElementById('imageGrid').width;
            imgH = document.getElementById('imageGrid').height;
            resizePointGridDiv();
            points.forEach(p => p.resize());
        }

        var warningTimeout;
        function updateWarning(str, err) {
            clearTimeout(warningTimeout);
            var w = document.getElementById('warning');
            var html = str;
            if (err) {
                html = '<b>' + html + '</b>';
            }
            w.innerHTML = html;
            warningTimeout = setTimeout( function() {
                document.getElementById('warning').innerHTML = '';
            }, 3000);
        }

        function generateCalibration() {
            if (imgLoaded) {
                var quadArr = [];
                var cellArr = [];
                var cellArrTemp = [];
                var cellX = parseFloat(document.getElementById('xOffset').value);
                var cellY = parseFloat(document.getElementById('yOffset').value);
                var cellW = parseFloat(document.getElementById('xWidth').value);
                var cellH = parseFloat(document.getElementById('yHeight').value);
                for (var i=0; i<=gridX; i++) {
                    quadArr.push([]);
                    cellArr.push([]);
                    for (var j=0; j<=gridY; j++) {
                        var index = i*(gridY+1) + j;
                        quadArr[i].push(points[index].pos);
                        var cellXP = cellX + cellW*i;
                        var cellYP = cellY + cellH*j;
                        cellArr[i].push({
                            x: cellXP,
                            y: cellYP
                        });
                    }
                }
                cellArrTemp = cellArr.map( m => m.map(c => (c)));
                if (xInverted) {
                    var arr = [];
                    for (var i=cellArrTemp.length-1; i>=0; i--) {
                        var arrI = cellArrTemp[i].map( m => (m));
                        arr.push(arrI);
                    }
                    cellArrTemp = arr.map( m => m.map(c => (c)));
                }
                if (yInverted) {
                    cellArrTemp = cellArrTemp.map( m => {
                        var arr = [];
                        for (var i=m.length-1; i>=0; i--) {
                            arr.push(m[i]);
                        }
                        return arr;
                    });
                }
                var time = Date.now();
                var quadArrString = JSON.stringify(quadArr);
                download(quadArrString, 'quads'+time, 'txt');
                var cellArrString = JSON.stringify(cellArrTemp);
                download(cellArrString, 'cells'+time, 'txt');
                updateWarning('Calibration files downloaded', true);
            } else {
                updateWarning('No calibration image loaded', true);
            }
        }

        function applyCalibration() {
            if (imgLoaded) {
                var calstr = document.getElementById('existingQuad').value;
                var cal = JSON.parse(calstr);
                if (cal.length===gridX+1 && cal[0].length===gridY+1) {
                    for (var i=0; i<cal.length; i++) {
                        for (var j=0; j<cal[i].length; j++) {
                            var index = i*(gridY+1) + j;
                            points[index].update(cal[i][j].x, cal[i][j].y);
                        }
                    }
                } else {
                    updateWarning('incorrect number of rows and columns', true);
                }
            } else {
                updateWarning('Load calibration image first', true);
            }
        }

        function download(data, filename, type) {
            var file = new Blob([data], {type: type});
            if (window.navigator.msSaveOrOpenBlob) // IE10+
                window.navigator.msSaveOrOpenBlob(file, filename);
            else { // Others
                var a = document.createElement("a"),
                        url = URL.createObjectURL(file);
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                setTimeout(function() {
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);  
                }, 0); 
            }
        }

        window.onload = function() {
            document.getElementById('loadImage').addEventListener('change', handleFiles, false);
            document.getElementById('buttonZoomIn').addEventListener('click', zoomIn);
            document.getElementById('buttonZoomOut').addEventListener('click', zoomOut);
            document.getElementById('generateCalibration').addEventListener('click', generateCalibration);
            document.getElementById('applyCalibration').addEventListener('click', applyCalibration);

            document.getElementById('pointGrid').addEventListener('click', function(e) {
                var mx = e.pageX;
                var my = e.pageY;
                var elePos = document.getElementById('pointGrid').getBoundingClientRect();
                mx = mx - elePos.left;
                my = my - elePos.top;
                windowClicked(mx, my);
            });
        };

        window.onresize = resizeGrid;

        window.onkeydown = function(e) {
            switch(e.key) {
                case 'ArrowLeft': //left
                    e.preventDefault();
                    arrowPressed(-1, 0);
                    break;
                case 'ArrowUp': //up
                    e.preventDefault();
                    arrowPressed(0, -1);
                    break;
                case 'ArrowRight': //right
                    e.preventDefault();
                    arrowPressed(1, 0);
                    break;
                case 'ArrowDown': //down
                    e.preventDefault();
                    arrowPressed(0, 1);
                    break;
                case 'Escape':
                    pointSelected.x = -1;                    
                    pointSelected.y = -1;
                    var activeElements = document.getElementsByClassName('active');
                    for (var i=0; i<activeElements.length; i++) {
                        activeElements[i].classList.remove('active');
                    }
                    updateWarning('No point selected', true);
                    break;
                default:
                    break;
            }
        }

    </script>
  </body>
</html>