<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>quad to rect mapping</title>
    <style>
      * {
        margin: 0;
        padding: 0;
      }

      canvas {
          position: absolute;
          top: 0;
          left: 0;
          width: 100vw;
          height: 100vh;
      }

    </style>
  </head>

  <body onload="init()">
    <canvas id="canvas">

    </canvas>

    <script>

        var c, ctx;
        var animation;

        var mX = 0, mY = 0;
        document.onmousemove = function(e) {
            mX = e.pageX;
            mY = e.pageY;
        }

        function init() {
            c = document.getElementById('canvas');
            c.width = window.innerWidth;
            c.height = window.innerHeight;
            ctx = c.getContext('2d');
            ctx.translate(0.5, 0.5);
            animation = setInterval(update, 30);
        }

        var quadPt = [
            {x:50, y:50},
            {x:300, y:75},
            {x:290, y:225},
            {x:100, y:300}
        ];

        var rectStartPt = {x: 400, y: 50};
        var rectW = 200;
        var rectH = 100;

        function update() {
            ctx.clearRect(-10, -10, c.width+10, c.height+10);
            drawQuad(quadPt);
            if (ptInQuad({x:mX, y:mY}, quadPt)) {
                ctx.fillStyle = 'red';
                var uvxy = mapQuad({x:mX, y:mY}, quadPt); 
                console.log(uvxy);
                ctx.fillRect(rectStartPt.x + uvxy.u*rectW-2, rectStartPt.y + uvxy.v*rectH-2, 4, 4);
            } else {
                ctx.fillStyle = 'black';
            }
            ctx.fillRect(mX-5, mY-5, 10, 10);
            ctx.strokeStyle = 'black'
            ctx.strokeRect(rectStartPt.x, rectStartPt.y, rectW, rectH);
        }

        function drawQuad(arr) {
            ctx.fillStyle = 'none';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 0.5;
            ctx.moveTo(arr[0].x, arr[0].y);
            for (var i=1; i<=arr.length; i++) {
                ctx.lineTo(arr[i%arr.length].x, arr[i%arr.length].y);
            }
            ctx.stroke();
        }

        function ptInQuad(pt, quadArr) {
            var quadArea = areaTriangle([quadArr[0], quadArr[1], quadArr[2]]) + areaTriangle([quadArr[0], quadArr[2], quadArr[3]]);
            var ptArea = 0;
            for (var i=0; i<quadArr.length; i++) {
                ptArea = ptArea + areaTriangle([pt, quadArr[i], quadArr[(i+1)%quadArr.length]]);
            }
            var ratio = ptArea / quadArea;
            if (ratio <= 1.0001) {
                return true;
            } else {
                return false;
            }
        }

        function mapQuad(pt, quadArr) {
            // https://math.stackexchange.com/questions/13404/mapping-irregular-quadrilateral-to-a-rectangle
            var p0 = quadArr[0];
            var p1 = quadArr[1];
            var p2 = quadArr[2];
            var p3 = quadArr[3];
            var dU0 = vecMag(vecSub(lineCP(p0, p3, pt), pt));
            var dU1 = vecMag(vecSub(lineCP(p1, p2, pt), pt));
            var u = dU0 / (dU0 + dU1);
            var dV0 = vecMag(vecSub(lineCP(p0, p1, pt), pt));
            var dV1 = vecMag(vecSub(lineCP(p3, p2, pt), pt));
            var v = dV0 / (dV0 + dV1);

            // var N0 = vecUnit(vecSub(lineCP(p0, p3, pt), pt));
            // var N1 = vecUnit(vecSub(lineCP(p0, p1, pt), pt));
            // var N2 = vecUnit(vecSub(lineCP(p1, p2, pt), pt));
            // var N3 = vecUnit(vecSub(lineCP(p3, p2, pt), pt));

            // var A = N0.x;
            // var B = N0.y;
            // var C = -vecDot(p0, N0);
            // var D = N0.x + N2.x;
            // var E = N0.y + N2.y;
            // var F = C - vecDot(p2, N2);
            // var G = N1.x;
            // var H = N1.y;
            // var I = -vecDot(p0, N1);
            // var J = N1.x + N3.x;
            // var K = N1.y + N3.y;
            // var L = I - vecDot(p2, N3);

            // var uDA = u*(D-A);
            // var uEB = u*(E-B);
            // var uFC = u*(F-C);
            // var vJG = v*(J-G);
            // var vKH = v*(K-H);
            // var vLI = v*(L-I);

            // var x = (vKH*uFC-vLI*uEB)/(vJG*uEB-vKH*uDA);
            // var y = (vLI*uDA-uFC*vJG)/(vJG*uEB-vKH*uDA);

            return {u:u, v:v};
        }

        function areaTriangle(arr) {
            return Math.abs(arr[0].x*(arr[1].y - arr[2].y) + arr[1].x*(arr[2].y - arr[0].y) + arr[2].x*(arr[0].y - arr[1].y))/2
        }

        function vecAdd(vec1, vec2) {
            return {x:vec1.x + vec2.x, y:vec1.y + vec2.y};
        }

        // vector vec1 ---> vec2
        function vecSub(vec1, vec2) {
            return {x:-vec1.x + vec2.x, y:-vec1.y + vec2.y};
        }

        function vecScale(vec, scale) {
            return {x:vec.x*scale, y:vec.y*scale};
        }

        function vecDot(vec1, vec2) {
            return vec1.x*vec2.x + vec1.y*vec2.y;
        }

        function vecMag(vec) {
            return Math.pow(Math.pow(vec.x, 2) + Math.pow(vec.y, 2), 0.5);
        }

        function vecMag2(vec) {
            return Math.pow(vec.x, 2) + Math.pow(vec.y, 2);
        }

        function vecUnit(vec) {
            var m = vecMag(vec);
            return {x: vec.x/m, y: vec.y/m};
        }

        function lineCP(sP, eP, pt) {
            var sToPt = vecSub(sP, pt);
            var sToE = vecSub(sP, eP);
            var magSE = vecMag2(sToE);
            var t = vecDot(sToPt, sToE) / magSE;
            return {x: sP.x + sToE.x*t, y: sP.y + sToE.y*t};
        }



    </script>
  </body>
</html>